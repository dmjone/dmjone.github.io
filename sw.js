(function () {/*

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/
    var aa = "function" == typeof Object.defineProperties ? Object.defineProperty : function (a, b, c) { if (a == Array.prototype || a == Object.prototype) return a; a[b] = c.value; return a }, ba = function (a) { a = ["object" == typeof globalThis && globalThis, a, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global]; for (var b = 0; b < a.length; ++b) { var c = a[b]; if (c && c.Math == Math) return c } throw Error("Cannot find global object"); }, ca = ba(this), da = function (a, b) {
        if (b) a: {
            var c = ca; a = a.split("."); for (var d = 0; d <
                a.length - 1; d++) { var e = a[d]; if (!(e in c)) break a; c = c[e] } a = a[a.length - 1]; d = c[a]; b = b(d); b != d && null != b && aa(c, a, { configurable: !0, writable: !0, value: b })
        }
    };
    da("String.prototype.matchAll", function (a) { return a ? a : function (b) { if (b instanceof RegExp && !b.global) throw new TypeError("RegExp passed into String.prototype.matchAll() must have global tag."); var c = new RegExp(b, b instanceof RegExp ? void 0 : "g"), d = this, e = !1, f = { next: function () { if (e) return { value: void 0, done: !0 }; var g = c.exec(d); if (!g) return e = !0, { value: void 0, done: !0 }; "" === g[0] && (c.lastIndex += 1); return { value: g, done: !1 } } }; f[Symbol.iterator] = function () { return f }; return f } }); var ea = this || self; var k = {}, l = null; var fa = "undefined" !== typeof Uint8Array; const n = "function" === typeof Symbol && "symbol" === typeof Symbol() ? Symbol() : void 0; function p(a, b) { if (n) return a[n] |= b; if (void 0 !== a.l) return a.l |= b; Object.defineProperties(a, { l: { value: b, configurable: !0, writable: !0, enumerable: !1 } }); return b } function q(a) { let b; n ? b = a[n] : b = a.l; return null == b ? 0 : b } function r(a, b) { n ? a[n] = b : void 0 !== a.l ? a.l = b : Object.defineProperties(a, { l: { value: b, configurable: !0, writable: !0, enumerable: !1 } }) }; var u = {}; function v(a) { return null !== a && "object" === typeof a && !Array.isArray(a) && a.constructor === Object } let w; const x = []; r(x, 23); Object.freeze(x); function y(a) { var b = a.length; (b = b ? a[b - 1] : void 0) && v(b) ? b.g = 1 : a.push({ g: 1 }) }; let z; function A(a) {
        switch (typeof a) {
            case "number": return isFinite(a) ? a : String(a); case "object": if (a) if (Array.isArray(a)) { if (0 !== (q(a) & 128)) return a = Array.prototype.slice.call(a), y(a), a } else if (fa && null != a && a instanceof Uint8Array) {
                var b; void 0 === b && (b = 0); if (!l) { l = {}; for (var c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), d = ["+/=", "+/", "-_=", "-_.", "-_"], e = 0; 5 > e; e++) { var f = c.concat(d[e].split("")); k[e] = f; for (var g = 0; g < f.length; g++) { var h = f[g]; void 0 === l[h] && (l[h] = g) } } } b = k[b];
                c = Array(Math.floor(a.length / 3)); d = b[64] || ""; for (e = f = 0; f < a.length - 2; f += 3) { var m = a[f], t = a[f + 1]; h = a[f + 2]; g = b[m >> 2]; m = b[(m & 3) << 4 | t >> 4]; t = b[(t & 15) << 2 | h >> 6]; h = b[h & 63]; c[e++] = "" + g + m + t + h } g = 0; h = d; switch (a.length - f) { case 2: g = a[f + 1], h = b[(g & 15) << 2] || d; case 1: a = a[f], c[e] = "" + b[a >> 2] + b[(a & 3) << 4 | g >> 4] + h + d }return c.join("")
            }
        }return a
    }; function B(a, b, c, d) { if (null != a) { if (Array.isArray(a)) a = C(a, b, c, void 0 !== d); else if (v(a)) { const e = {}; for (let f in a) e[f] = B(a[f], b, c, d); a = e } else a = b(a, d); return a } } function C(a, b, c, d) { const e = q(a); d = d ? !!(e & 16) : void 0; a = Array.prototype.slice.call(a); for (let f = 0; f < a.length; f++)a[f] = B(a[f], b, c, d); c(e, a); return a } function ha(a) { return a.u === u ? a.toJSON() : A(a) } function ia(a, b) { a & 128 && y(b) }; var D = function (a, b) { return -1 === b ? null : b >= a.m ? a.h ? a.h[b] : void 0 : a.j[b + a.i] }; function E(a, b, c, d) { a.o && (a.o = void 0); b >= a.m || d ? (a.h || (a.h = a.j[a.m + a.i] = {}))[b] = c : (a.j[b + a.i] = c, (a = a.h) && b in a && delete a[b]) } function F(a, b, c, d) { if (q(a.j) & 2) throw Error("Cannot mutate an immutable Message"); c !== d ? E(a, b, c) : E(a, b, void 0, !1); return a } var G = function (a, b) { a = D(a, b); return null == a ? "" : a }; var H = function (a, b) { if (null == b || "" == b) return new a; b = JSON.parse(b); if (!Array.isArray(b)) throw Error(void 0); p(b, 16); z = b; a = new a(b); z = void 0; return a }, I = function (a) { w = !0; try { return JSON.stringify(a.toJSON(), ja) } finally { w = !1 } }, J = class {
        constructor(a) {
            null == a && (a = z); z = void 0; var b = this.constructor.h || 0; const c = 0 < b, d = this.constructor.i; var e; if (null == a) a = d ? [d] : [], r(a, 48); else {
                if (!Array.isArray(a)) throw Error(); if (d && d !== a[0]) throw Error(); const f = p(a, 0); let g = f; if (e = 0 !== (16 & g)) (e = 0 !== (32 & g)) || (g |= 32);
                if (c) if (128 & g) b = 0; else { if (0 < a.length && (e = a[a.length - 1], v(e) && "g" in e)) { b = 0; g |= 128; delete e.g; let h = !0; for (let m in e) { h = !1; break } h && a.pop() } } else if (128 & g) throw Error(); f !== g && r(a, g)
            } this.i = (d ? 0 : -1) - b; this.j = a; a: { b = this.j.length; a = b - 1; if (b && (b = this.j[a], v(b))) { this.h = b; this.m = a - this.i; break a } this.m = Number.MAX_VALUE } if (!c && this.h && "g" in this.h) throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');
        } toJSON() { const a = this.j; return w ? a : C(a, ha, ia) }
    }; J.prototype.u = u;
    J.prototype.toString = function () { return this.j.toString() }; function ja(a, b) { return A(b) }; var ka = class extends J { }; var la = [/^https:\/\/cloud.google.com\/blog.*/, /\.mp4$/, /^https:\/\/uberproxy.*/, /livereload(.js)?$/, /clients[0-9]+\.google.com/]; let K = null; var L = function (a) { return a.i ? Promise.resolve() : new Promise(b => { const c = ea.indexedDB.open("devsite-index-db", 1); c.onsuccess = () => { a.h = c.result; a.i = !0; b() }; c.onerror = d => { throw Error(d); }; c.onupgradeneeded = d => { d = d.target.result.createObjectStore("userPreferences", { keyPath: "name" }); d.createIndex("name", "name", { unique: !0 }); d.createIndex("value", "value", { unique: !1 }) } }) };
    class ma { constructor() { this.h = null; this.i = !1; try { L(this) } catch (a) { console.warn(a) } } async set(a, b) { await L(this); try { const c = this.h.transaction(["userPreferences"], "readwrite"); c.objectStore("userPreferences").put({ name: a, value: b }); return new Promise(d => { c.oncomplete = d }) } catch (c) { console.warn(c) } } async get(a) { await L(this); try { const b = this.h.transaction(["userPreferences"], "readwrite").objectStore("userPreferences").get(a); return new Promise(c => { b.onsuccess = () => { c(b.result ? b.result.value : void 0) } }) } catch (b) { console.warn(b) } } }
    ; var M = ["content-length", "etag", "last-modified"]; function N(a) { a = new URL(a); return ["fonts.googleapis.com", "fonts.gstatic.com", "localhost"].includes(a.hostname) ? !0 : ["www.gstatic.com", "gstatic.com"].includes(a.hostname) ? a.pathname.startsWith("/devrel-devsite/") || a.pathname.startsWith("/external_hosted/") : !1 }; var P = function (a) { var b = new O; return F(b, 1, a, 0) }, O = class extends J { }; var Q = function (a, b) { if ("GET" !== b.method) return !1; b = new URL(b.url, a.location.origin); return b.hostname === a.location.hostname ? !0 : N(b.href) }, R = function (a) { return new URL(a.request.url, a.h.location.origin) }, S = function (a) { const b = R(a); let c, d; return -1 === (null == (d = null != (c = b.pathname.split("/").pop()) ? c : "") ? void 0 : d.indexOf(".")) && b.origin === a.h.location.origin }, T = function (a) { const b = R(a); return S(a) && b.searchParams.has("partial") }, U = async function (a) { return a.h.caches.open("devsite.pwa_RUNTIME_v2.1") },
        V = async function (a) { const b = await a.text(); let c; try { c = H(ka, b) } catch (e) { } const d = new Headers(a.headers); d.set("Content-Type", "text/html"); a = { status: a.status, statusText: a.statusText, headers: d }; return c ? new Response(G(c, 1), a) : new Response(b, a) }, W = async function (a, b) { b = new URL(b); if (b.searchParams.has("hl")) return b; S(a) && (a = await a.i.get("language_preference"), b.searchParams.set("hl", a || "en")); return b }, X = async function (a) {
            const b = await U(a); var c = R(a); c = await W(a, c.href); return S(a) && !T(a) && (a = new URL(c.href),
                a.searchParams.set("partial", "1"), a = await (null == b ? void 0 : b.match(a.href))) ? V(a) : (null == b ? void 0 : b.match(c.href)) || void 0
        }, na = function (a, b) { return a && b ? M.some(c => a.headers.has(c) && b.headers.has(c)) ? M.every(c => a.headers.has(c) === b.headers.has(c) && a.headers.get(c) === b.headers.get(c)) : !1 : !1 }, oa = async function (a, b) { b = I(b); if (a = await a.h.clients.matchAll()) for (const c of a) c.postMessage(b) }, Y = function () { return new Response("<h1>Service Unavailable</h1>", { status: 503, statusText: "Service Unavailable", headers: new Headers({ "Content-Type": "text/html" }) }) },
        pa = async function (a) { const b = await U(a), c = await W(a, a.request.url), d = await (null == b ? void 0 : b.match(c.href)), e = a.h.fetch(a.request).then(f => { if (f && (null == b || b.put(c.href, f.clone()), d && R(a).pathname.match(/\.(jpeg|jpg|gif|png|svg|webp|avi|mp4|mov)$/) && !na(d, f) && [...f.headers.keys()].length)) { var g = P(2); g = F(g, 2, a.request.url, ""); oa(a, g) } return f }).catch(() => Y()); return d || e }, qa = async function (a, b) {
            const c = await U(a); if (c) try {
                const d = await W(a, a.request.url); b.ok ? await c.put(d.href, b.clone()) : 404 === b.status &&
                    await c.delete(d.href)
            } catch (d) { }
        }, ra = async function (a) { try { var b = await a.h.fetch(a.request.clone()); if (b) return await qa(a, b), b; const c = await X(a); return c ? c : Y() } catch (c) { if (b = await X(a)) return b; if (S(a)) { let d; if (b = await (null == (d = await U(a)) ? void 0 : d.match("/_static/offline?partial=1"))) return T(a) ? b : V(b) } return Y() } }, sa = class {
            constructor(a, b) { this.h = a; this.request = b; K || (K = new ma); this.i = K } async fetch() {
                if (!Q(this.h, this.request)) return this.h.fetch(this.request); var a = await X(this), b; if (b = a) {
                    b =
                        a.headers.get("date"); const c = a.headers.get("expires"); let d = !1, e = !1; b && (d = 6E4 > Date.now() - (new Date(b)).getTime()); c && (e = 0 < (new Date(c)).getTime() - Date.now()); b = d || e
                } b || (b = R(this), a = !!b.pathname.match(/\.(jpeg|jpg|gif|png|svg|webp|avi|mp4|mov|css|js)$/), b = b.origin === this.h.location.origin || N(b.href), a = a && b ? pa(this) : ra(this)); return a
            }
        }; const ta = [/^utm_/, RegExp("^dcb_$")]; var wa = async function (a, b) { if (!Q(a.h, b) || ua(b)) return a.h.fetch(b).catch(() => new Response("<h1>Service Unavailable</h1>", { status: 503, statusText: "Service Unavailable", headers: new Headers({ "Content-Type": "text/html" }) })); b = await va(a, b.clone()); return (new sa(a.h, b)).fetch() }, xa = async function (a) { const b = (await a.h.caches.keys()).filter(c => c !== a.cacheName); await Promise.all(b.map(c => a.h.caches.delete(c))) }, ya = async function (a, b) {
            const c = a.h.location, d = c.origin, e = {}; (new URL(b, c.origin)).origin === d ? e.credentials =
                "include" : e.mode = "no-cors"; b = new Request(b, e); try { await wa(a, b) } catch (f) { }
        }, ua = function (a) { const b = "navigate" === a.mode, c = "1" === a.headers.get("Upgrade-Insecure-Requests"); a = -1 !== (a.headers.get("Accept") || "").indexOf("text/html"); return b && c && a }, va = async function (a, b) {
            const c = b.clone(), d = new URL(b.url, a.h.location.origin); if (ua(b) || d.origin !== a.h.location.origin && !N(d.href)) return c; d.hash = ""; var e = [...d.searchParams.keys()]; for (var f of e) for (const h of ta) f.match(h) && d.searchParams.delete(f); e = new Headers;
            for (var g of b.headers.entries()) g[1] && e.append(g[0], g[1]); g = null; if ("GET" !== b.method && "HEAD" !== b.method) try { g = await b.text() } catch (h) { return c } f = b.mode; d.origin === a.h.location.origin && d.pathname.startsWith("/_static/") && (f = "no-cors"); a = { method: b.method, mode: f, body: g, redirect: b.redirect, headers: e, credentials: b.credentials, cache: b.cache, referrer: b.referrer }; try { return new Request(d.href, a) } catch (h) { return c }
        }, Z = new class {
            constructor(a, b) { this.h = a; this.i = b } v(a) { a.waitUntil(this.h.skipWaiting()) } s(a) {
                let b =
                    "GET" !== a.request.method || a.request.headers.has("range"); la.find(c => c.test(a.request.url)) && (b = !0); b || a.respondWith(wa(this.i, a.request))
            } o(a) { a.waitUntil(xa(this.i).then(() => this.h.clients.claim()).then(async () => { const b = I(P(4)), c = await this.h.clients.matchAll({ type: "window" }); if (c) for (const d of c) d.postMessage(b) })) } async m(a) {
                const b = a.data; try { var c = H(O, b) } catch (e) { return } let d = D(c, 1); switch (null == d ? 0 : d) {
                    case 1: await ya(this.i, G(c, 2)); break; case 3: case 5: case 6: if (c = await this.h.clients.matchAll({ type: "window" }),
                        a = a.source, b && c) for (const e of c) e.id !== a.id && e.postMessage(b)
                }
            }
        }(self, new class { constructor(a, b = "devsite.pwa_RUNTIME_v2.1") { this.h = a; this.cacheName = b; this.caches = new Map } }(self)); (async function (a) { var b = b ? b : a.cacheName; let c = a.caches.get(b); c || (c = await a.h.caches.open(b)) && a.caches.set(b, c) })(Z.i); Z.h.oninstall = Z.v.bind(Z); Z.h.onactivate = Z.o.bind(Z); Z.h.onfetch = Z.s.bind(Z); Z.h.onmessage = Z.m.bind(Z);
}).call(this);